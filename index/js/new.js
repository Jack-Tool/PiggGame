// --- Generalized Slider Setup Function ---
function setupPartSlider(partName, facesPerSlide = 15, dynamicContent = false) {
    const ul = document.getElementById(`${partName}-shapes`); // e.g., 'face-shapes', 'eyebrow-shapes'
    if (!ul) {
        console.warn(`UL with id ${partName}-shapes not found. Skipping slider setup for ${partName}.`);
        return; // Exit if the UL isn't found
    }

    // Capture initial children if not dynamically generated by JS inside HTML
    const initialItems = Array.from(ul.children); // Create a static array copy

    // If content is dynamically added by JS within the HTML, ensure it's run first.
    // In your case, the face-shapes are generated directly in HTML's script tag,
    // so `ul.children` will already contain them when this function runs for 'face'.

    const total = initialItems.length;
    const maxSlide = Math.ceil(total / facesPerSlide) - 1;
    let slide = 0; // Current slide index

    // Get elements specific to THIS part's slider menu
    const sliderMenu = document.querySelector(`.spg-slider-menu[data-part="${partName}"]`);
    if (!sliderMenu) {
        console.warn(`Slider menu with data-part="${partName}" not found. Skipping slider setup for ${partName}.`);
        return;
    }
    const indicator = sliderMenu.querySelector('.slide-indicator');
    const prevBtn = sliderMenu.querySelector('.spg-slider-prev');
    const nextBtn = sliderMenu.querySelector('.spg-slider-next');
    const prev2Btn = sliderMenu.querySelector('.spg-slider-prev2'); 
    const next2Btn = sliderMenu.querySelector('.spg-slider-next2');

    // --- Core Slider Logic ---

    // Array to hold the new <ul> slide elements
    const slides = [];

    // Helper function to update the indicator text
    function updateIndicator() {
        if (indicator) { // Check if indicator exists for this part
            indicator.textContent = `${slide + 1} / ${maxSlide + 1}`;
        }
    }

    // Function to show a specific slide and manage button states
    function showSlide(newSlide) {
        // Ensure the new slide index is within valid bounds
        slide = Math.max(0, Math.min(newSlide, maxSlide));

        slides.forEach((s, i) => {
            if (i === slide) {
                s.style.opacity = '1';
                s.style.pointerEvents = 'auto';
                s.style.zIndex = '1';
            } else {
                s.style.opacity = '0';
                s.style.pointerEvents = 'none';
                s.style.zIndex = '0';
            }
        });

        // Update button disabled states
        if (prevBtn) prevBtn.disabled = slide === 0;
        if (nextBtn) nextBtn.disabled = slide === maxSlide;
        if (prev2Btn) prev2Btn.disabled = slide === 0;
        if (next2Btn) next2Btn.disabled = slide === maxSlide;

        updateIndicator(); // Update the visual indicator
    }

    // Dynamically create new UL elements for each slide and move existing LIs into them
    // Only do this if there are actually items to put into slides
    if (total > 0) {
        for (let i = 0; i <= maxSlide; i++) {
            const slideEl = document.createElement('ul');
            slideEl.className = 'options spg-slider-target'; // Keep existing classes
            // Apply CSS for grid layout and positioning (adjust as needed for specific parts)
            slideEl.style.display = 'grid';
            slideEl.style.gridTemplateColumns = 'repeat(5, 60px)'; // 5 columns, 60px wide
            slideEl.style.gridTemplateRows = 'repeat(3, 60px)'; // 3 rows, 60px high
            slideEl.style.gap = '14px 30px'; // Adjust gap as needed
            slideEl.style.position = 'absolute';
            slideEl.style.top = '0';
            slideEl.style.left = '0';
            slideEl.style.transition = 'opacity 0.3s';
            slideEl.style.opacity = '0'; // Start hidden
            slideEl.style.pointerEvents = 'none'; // Not interactive initially

            // Move the original items from initialItems array
            for (let j = 0; j < facesPerSlide && (i * facesPerSlide + j) < total; j++) {
                slideEl.appendChild(initialItems[i * facesPerSlide + j]);
            }
            ul.parentElement.appendChild(slideEl); // Add the new slide ULs to the DOM
            slides.push(slideEl); // Store references to the slide ULs
        }

        // Remove the original UL element now that its children have been moved
        ul.remove();
    } 


    // Event listeners for basic next/prev buttons
    if (prevBtn) {
        prevBtn.addEventListener('click', () => {
            showSlide(slide - 1);
        });
    }
    if (nextBtn) {
        nextBtn.addEventListener('click', () => {
            showSlide(slide + 1);
        });
    }

    // Event listeners for fast next/prev buttons (if they exist)
    if (prev2Btn) {
        prev2Btn.addEventListener('click', () => {
            showSlide(slide - 10); // Jump by 10 slides
        });
    }
    if (next2Btn) {
        next2Btn.addEventListener('click', () => {
            showSlide(slide + 10); // Jump by 10 slides
        });
    }

    // Initialize the slider to show the first slide
    showSlide(0);
}

// --- Call the generalized function for each part ---
// Note: The facesPerSlide (items per grid) and grid layout might need adjustment per part.
// For example, if eyebrows only have 2 options, you might not want a grid of 15.
// For now, I'm keeping the 15 and 5x3 grid for all, but you can pass different values.

// Call setup for 'face' (facesPerSlide = 15 for 5x3 grid)
setupPartSlider('face', 15);

// Call setup for 'eyebrow' (adjust facesPerSlide and grid if needed)
setupPartSlider('eyebrow', 15); // Adjust facesPerSlide if you want fewer items per slide

// Call setup for 'eye'
setupPartSlider('eye', 15);

// Call setup for 'nose'
setupPartSlider('nose', 15);

// Call setup for 'mouth'
setupPartSlider('mouth', 15);

// Call setup for 'frontHair'
setupPartSlider('frontHair', 15);

// Call setup for 'backHair'
setupPartSlider('backHair', 15);

// Call setup for 'mole'
setupPartSlider('mole', 15);

// Call setup for 'beard'
setupPartSlider('beard', 15);

// Call setup for 'option'
setupPartSlider('option', 15);


// --- Existing Popup and Part Selector Logic (Keep these) ---

// Custom Popup Functionality
document.getElementById('open-custom-popup').addEventListener('click', function() {
    document.getElementById('custom-popup-bg').style.display = 'block';
    document.getElementById('custom-popup').style.display = 'block';
});

document.getElementById('close-custom-popup').addEventListener('click', function() {
    document.getElementById('custom-popup-bg').style.display = 'none';
    document.getElementById('custom-popup').style.display = 'none';
});

document.getElementById('custom-popup-bg').addEventListener('click', function() {
    document.getElementById('custom-popup-bg').style.display = 'none';
    document.getElementById('custom-popup').style.display = 'none';
});

// Handle part link clicks (this block should remain as is)
document.querySelectorAll('#custom-part-list a').forEach(function(link) {
    link.addEventListener('click', function(e) {
        e.preventDefault();
        const part = this.getAttribute('data-part');

        document.querySelectorAll('#shapeSelectorContainer .shapeSelector').forEach(function(sec) {
            sec.style.display = 'none';
        });

        const target = document.querySelector('#shapeSelectorContainer .shapeSelector[data-part="' + part + '"]');
        if (target) {
            target.style.display = 'block';
        }

        document.getElementById('custom-popup-bg').style.display = 'none';
        document.getElementById('custom-popup').style.display = 'none';
    });


    
});




document.addEventListener('DOMContentLoaded', function () {
    function renderOptions(containerId, name, imagePath, prefix, count) {
        const container = document.getElementById(containerId);
        if (!container) return;
        // If this part has a _null image (exclude face, for example)
        const excludedNullParts = ['face', 'eye' , 'nose' , 'mouth']; //expand if needed
        const hasNullImage = !excludedNullParts.includes(name);

        if (hasNullImage) {
        const li = document.createElement('li');
        li.className = `${name}-option`;

        const input = document.createElement('input');
        input.type = 'radio';
        input.name = name;
        input.id = `${name}_null`;

        const label = document.createElement('label');
        label.htmlFor = `${name}_null`;

        const img = document.createElement('img');
        img.src = `${imagePath}/${prefix}null.png`;
        img.alt = `${name.charAt(0).toUpperCase() + name.slice(1)} None`;

        label.appendChild(img);
        li.appendChild(input);
        li.appendChild(label);
        container.appendChild(li);
    }

        for (let i = 0; i < count; i++) {
            const li = document.createElement('li');
            li.className = `${name}-option`;

            const input = document.createElement('input');
            input.type = 'radio';
            input.name = name;
            input.id = `${name}_${i}`;

            const label = document.createElement('label');
            label.htmlFor = `${name}_${i}`;

            const img = document.createElement('img');
            img.src = `${imagePath}/${prefix}${i}.png`;
            img.alt = `${name.charAt(0).toUpperCase() + name.slice(1)} ${i}`;

            label.appendChild(img);
            li.appendChild(input);
            li.appendChild(label);
            container.appendChild(li);
        }
        
    }


   


    for (const [part, count] of Object.entries(shapeCounts)) {
  renderOptions(`${part}-shapes`, part, `index/img/edit/${part}Shapes`, `${part}_`, count);

}



    // ⚠️ Setup the sliders AFTER the content is rendered
    setupPartSlider('face', 15);
    setupPartSlider('eye', 15);
    setupPartSlider('mouth', 15);
    setupPartSlider('eyebrow', 15);
});
                                         